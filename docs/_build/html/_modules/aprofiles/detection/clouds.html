<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aprofiles.detection.clouds &mdash; A-Profiles  documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> A-Profiles
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">A-Profiles</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>aprofiles.detection.clouds</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aprofiles.detection.clouds</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<div class="viewcode-block" id="detect_clouds"><a class="viewcode-back" href="../../../api.html#aprofiles.detection.clouds.detect_clouds">[docs]</a><span class="k">def</span> <span class="nf">detect_clouds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_avg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thr_noise</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">min_snr</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Module for *clouds detection*.</span>
<span class="sd">    The detection is performed on each single profile individually. It is based on the analysis of the vertical gradient of the profile as respect to the level of noise measured in the profile.</span>

<span class="sd">    Args:</span>
<span class="sd">        - time_avg (int, optional): in minutes, the time during which we aggregates the profiles prior to the clouds detection. Defaults to `1`.</span>
<span class="sd">        - zmin (float, optional): altitude AGL, in m, above which we look for clouds. Defaults to `0`. We recommend using the same value as used in the extrapolation_low_layers method.</span>
<span class="sd">        - thr_noise (float, optional): threshold used in the test to determine if a couple (base,peak) is significant: data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z). Defaults to `5`.</span>
<span class="sd">        - thr_clouds (float, optional): threshold used to discriminate aerosol from clouds: data[peak(z)] / data[base(z)] &gt;= thr_clouds. Defaults to `4`.</span>
<span class="sd">        - min_snr (float, optional). Minimum SNR required at the clouds peak value to consider the cloud as valid. Defaults to `0`.</span>
<span class="sd">        - verbose (bool, optional): verbose mode. Defaults to `False`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`ProfilesData` object with additional Data Arrays.</span>
<span class="sd">            - :class:`xarray.DataArray &#39;clouds_bases&#39; (time, altitude)`: mask array corresponding to the bases of the clouds.</span>
<span class="sd">            - :class:`xarray.DataArray &#39;clouds_peaks&#39; (time, altitude)`: mask array corresponding to the peaks (maximum signal measured) of the clouds.</span>
<span class="sd">            - :class:`xarray.DataArray &#39;clouds_tops&#39; (time, altitude)`: mask array corresponding to the top of the cloud if the beam crosses the cloud. If not, the top corresponds to the first value where the signal becomes lower than the one measured at the base of the cloud.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import aprofiles as apro</span>
<span class="sd">        &gt;&gt;&gt; #read example file</span>
<span class="sd">        &gt;&gt;&gt; path = &quot;examples/data/L2_0-20000-001492_A20210909.nc&quot;</span>
<span class="sd">        &gt;&gt;&gt; reader = apro.reader.ReadProfiles(path)</span>
<span class="sd">        &gt;&gt;&gt; profiles = reader.read()</span>
<span class="sd">        &gt;&gt;&gt; #clouds detection</span>
<span class="sd">        &gt;&gt;&gt; profiles.clouds(zmin=300.)</span>
<span class="sd">        &gt;&gt;&gt; #attenuated backscatter image with clouds</span>
<span class="sd">        &gt;&gt;&gt; profiles.plot(show_clouds=True, vmin=1e-2, vmax=1e1, log=True)</span>

<span class="sd">        .. figure:: _static/_images/clouds.png</span>
<span class="sd">            :scale: 50 %</span>
<span class="sd">            :alt: clouds detection</span>

<span class="sd">            Clouds detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_detect_clouds_from_rcs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">thr_noise</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">):</span>
        <span class="c1">#data: 1D range corrected signal (rcs)</span>
        <span class="c1">#zmin: altitude AGL, in m, above which we detect clouds</span>
        <span class="c1">#thr_noise: threshold used in the test to determine if a couple (base,peak) is significant: data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z)</span>
        <span class="c1">#thr_clouds: threshold used to discriminate aerosol from clouds: data[peak(z)] / data[base(z)] &gt;= thr_clouds</span>
        <span class="c1">#min_snr: minimum SNR required at the clouds peak value to consider the cloud as valid. Defaults to 2.</span>
        
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
        <span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">uniform_filter1d</span>

        <span class="c1">#some useful functions:</span>
        <span class="k">def</span> <span class="nf">get_indexes</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="c1">#mask: list of Bool</span>
            <span class="c1">#returns a list indexes where the mask is True</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_get_all_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">tops</span><span class="o">=</span><span class="p">[]):</span>
            <span class="c1">#get True indexes of bases, peaks and tops, based on masks</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
            <span class="n">i_tops</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span>

        <span class="k">def</span> <span class="nf">make_mask</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">indexes_where_True</span><span class="p">):</span>
            <span class="c1">#length: int: length of the mask</span>
            <span class="c1">#indexes_where_true: list</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">length</span><span class="p">)])</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">indexes_where_True</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes_where_True</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">mask</span>

        <span class="k">def</span> <span class="nf">_make_all_masks</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span><span class="o">=</span><span class="p">[]):</span>
            <span class="c1">#return masks for bases, peaks and tops based on input indexes</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_bases</span><span class="p">)</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_peaks</span><span class="p">)</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_tops</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">tops</span>


        <span class="k">def</span> <span class="nf">_snr_at_iz</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
            <span class="c1">#calculates the snr from array at iz around step points</span>
            <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iz</span><span class="o">-</span><span class="n">step</span><span class="p">,</span><span class="n">iz</span><span class="o">+</span><span class="n">step</span><span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gates</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">std</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mean</span><span class="o">/</span><span class="n">std</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">_merge_layers</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span><span class="p">):</span>
            <span class="c1">#merge layers depending on the altitude of the bases and the tops</span>
            <span class="n">remove_mode</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">remove_mode</span><span class="p">:</span>
                <span class="n">remove_bases</span><span class="p">,</span> <span class="n">remove_peaks</span><span class="p">,</span> <span class="n">remove_tops</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1">#filters based on the index</span>
                    <span class="k">if</span> <span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
                        <span class="n">remove_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                        <span class="c1">#remove the weakest peak</span>
                        <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]])</span>
                        <span class="n">remove_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">imin</span><span class="p">])</span>
                        <span class="c1">#remove lowest top</span>
                        <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
                        <span class="n">remove_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">imin</span><span class="p">])</span>
                        <span class="c1">#start again from the bottom</span>
                        <span class="k">break</span>

                <span class="n">i_bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_bases</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_bases</span><span class="p">]</span>
                <span class="n">i_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_peaks</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_peaks</span><span class="p">]</span>
                <span class="n">i_tops</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_tops</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_tops</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remove_bases</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">remove_mode</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span>


        <span class="k">def</span> <span class="nf">_find_tops</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">):</span>
            <span class="c1">#function that finds the top of the layers by identifying the first value above thepeak for which the signal is lower than the base</span>
            <span class="c1">#if no top is found, the layer is removed</span>
            <span class="c1">#retruns lists of indexes of the bases, peaks and tops</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
            <span class="c1"># conditions: look for bases above i_peaks[i], and data[top[i]] &lt;= data[base[i]]</span>
            
            <span class="n">i_tops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
                <span class="n">mask_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">True</span> <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
                <span class="n">mask_altitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">True</span> <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
                <span class="c1">#the top is the first value that corresponds to the intersection of the two masks</span>
                <span class="n">cross_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask_value</span><span class="p">,</span> <span class="n">mask_altitude</span><span class="p">)</span>
                <span class="n">i_cross_mask</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">cross_mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_cross_mask</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                        <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">i_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#it is important to keep the tops in the same order, so not to use get_indexes() function here</span>
            <span class="k">return</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">),</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">),</span> <span class="n">i_tops</span>
        
        <span class="k">def</span> <span class="nf">_find_tops2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">):</span>
            <span class="c1">#function that finds the top of the layers by identifying the positive gradient above the peak</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
            <span class="n">i_tops</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
                <span class="n">mask_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">True</span> <span class="k">if</span> <span class="n">gradient</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
                <span class="n">mask_altitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">True</span> <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
                <span class="c1">#the top is the first value that corresponds to the intersection of the two masks</span>
                <span class="n">cross_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask_value</span><span class="p">,</span> <span class="n">mask_altitude</span><span class="p">)</span>
                <span class="n">i_cross_mask</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">cross_mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_cross_mask</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                        <span class="c1">#print(&#39;top already found. remove current layer&#39;)</span>
                        <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">i_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print(&#39;no top found for base&#39;,i_bases[i])</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#it is important to keep the tops in the same order, so not to use get_indexes() function here</span>
            <span class="k">return</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">),</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">),</span> <span class="n">i_tops</span>



        <span class="c1">#0. rolling average</span>
        <span class="n">avg_data</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>


        <span class="c1">#1. first derivative</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">avg_data</span><span class="p">)</span>


        <span class="c1">#2. identifies peaks and base by checking the sign changes of the derivative</span>
        <span class="n">sign_changes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">gradient</span><span class="p">),</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">all_bases</span> <span class="o">=</span> <span class="n">sign_changes</span><span class="o">==</span><span class="mi">2</span>
        <span class="n">all_peaks</span> <span class="o">=</span> <span class="n">sign_changes</span><span class="o">==-</span><span class="mi">2</span>
        <span class="c1">#limit to bases above zmin</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">zmin</span><span class="p">)</span>
        <span class="n">all_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]))]</span>
        <span class="n">all_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]))]</span>
        <span class="c1">#get indexes</span>
        <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_bases</span><span class="p">)</span>
        <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">)</span>


        <span class="c1">#3. the signal should start with a base</span>
        <span class="k">if</span> <span class="n">i_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#set base as the minimum between peak and n gates under</span>
            <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">i_base</span> <span class="o">=</span> <span class="n">gates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">gates</span><span class="p">[</span><span class="n">gates</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]]])]</span>
            <span class="k">if</span> <span class="n">i_base</span><span class="o">&gt;=</span><span class="n">imin</span><span class="p">:</span>
                <span class="n">all_bases</span><span class="p">[</span><span class="n">i_base</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#update indexes</span>
        <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_bases</span><span class="p">)</span>
        <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">)</span>


        <span class="c1">#4. keeps significant couples (base,peak)</span>
        <span class="c1"># a layer can be considered as a proper layer if the difference of signal between the peak and the base is significant (larger than the noise level)</span>
        <span class="c1"># noise evaluation (using a high passing frequency filter)</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="c1">#rolling average of the noise</span>
        <span class="n">avg_abs_noise</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">noise</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="c1">#make sure we have as many peaks as bases</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">):</span>
            <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)])</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_len</span><span class="p">]</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">i_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_len</span><span class="p">]</span>
        <span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span> <span class="o">=</span> <span class="n">all_bases</span><span class="p">,</span> <span class="n">all_peaks</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
            <span class="n">data_around_peak</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">data_around_base</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">data_around_peak</span> <span class="o">-</span> <span class="n">data_around_base</span> <span class="o">&lt;=</span> <span class="n">thr_noise</span> <span class="o">*</span> <span class="n">avg_abs_noise</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#get indexes</span>
        <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
        <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>


        <span class="c1">#5. make sure we finish by a peak: remove last base if necessary</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">):</span>
            <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">i_bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>


        <span class="c1">#6. find tops of clouds layers</span>
        <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span> <span class="o">=</span> <span class="n">_find_tops</span><span class="p">(</span><span class="n">avg_data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">)</span>


        <span class="c1">#7. merge layers: for a couple of base and peaks 1,2 if data(b2)&gt;data(p1), then merge layers 1 and 2 by removing p1 and b2</span>
        <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span> <span class="o">=</span> <span class="n">_merge_layers</span><span class="p">(</span><span class="n">avg_data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span><span class="p">)</span>


        <span class="c1">#8. find peaks as maximum between base and top</span>
        <span class="n">i_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">))]</span>
        <span class="c1">#reconstruct masks</span>
        <span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">tops</span> <span class="o">=</span> <span class="n">_make_all_masks</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span><span class="p">)</span>


        <span class="c1">#9. distinction between aerosol and clouds</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
            <span class="n">data_around_peak</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">data_around_base</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">data_around_peak</span> <span class="o">-</span> <span class="n">data_around_base</span><span class="p">)</span> <span class="o">/</span> <span class="n">data_around_base</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thr_clouds</span><span class="p">:</span>
                <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">tops</span><span class="p">[</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#get indexes</span>
        <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span> <span class="o">=</span> <span class="n">_get_all_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">tops</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        #10. set base a closest index</span>
<span class="sd">        for i, _ in enumerate(i_peaks):</span>
<span class="sd">            mask_value = np.asarray([True if gradient[j]&lt;0 else False for j in range(len(data))])</span>
<span class="sd">            mask_altitude = np.asarray([True if j&lt;i_peaks[i] else False for j in range(len(data))])</span>
<span class="sd">            #the top is the first value that corresponds to the intersection of the two masks</span>
<span class="sd">            cross_mask = np.logical_and(mask_value, mask_altitude)</span>
<span class="sd">            i_cross_mask = get_indexes(cross_mask)</span>
<span class="sd">            i_bases[i] = i_cross_mask[-1]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#11. check snr at peak levels</span>
        <span class="n">remove_bases</span><span class="p">,</span> <span class="n">remove_peaks</span><span class="p">,</span> <span class="n">remove_tops</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">_snr_at_iz</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">step</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;</span><span class="n">min_snr</span><span class="p">:</span>
                <span class="n">remove_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">remove_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">remove_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># remove indexes</span>
        <span class="n">i_bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_bases</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_bases</span><span class="p">]</span>
        <span class="n">i_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_peaks</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_peaks</span><span class="p">]</span>
        <span class="n">i_tops</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_tops</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_tops</span><span class="p">]</span>


        <span class="c1">#11. rebuild masks from indexes</span>
        <span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">tops</span> <span class="o">=</span> <span class="n">_make_all_masks</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_bases</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">,</span> <span class="n">i_tops</span><span class="p">)</span>
        
        
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        #some plotting</span>
<span class="sd">        fig, axs = plt.subplots(1,2,figsize=(10,10))</span>
<span class="sd">        </span>
<span class="sd">        ymin, ymax = 000, 15000</span>
<span class="sd">        altitude_agl = profiles.data.altitude.data - profiles.data.station_altitude.data</span>
<span class="sd">        </span>
<span class="sd">        #signal on the left</span>
<span class="sd">        axs[0].plot(data, altitude_agl, &#39;b&#39;, label=&#39;rcs&#39;)</span>
<span class="sd">        axs[0].plot(avg_data, altitude_agl, &#39;c&#39;, label=&#39;rcs&#39;)</span>
<span class="sd">        axs[0].plot(avg_abs_noise,altitude_agl,&#39;:b&#39;, label=&#39;noise level&#39;)</span>
<span class="sd">        axs[0].plot(avg_abs_noise*thr_noise,altitude_agl,&#39;:b&#39;, label=&#39;noise level * {}&#39;.format(thr_noise))</span>
<span class="sd">        axs[0].plot(data[bases], altitude_agl[bases], &#39;&lt;g&#39;, label=&#39;bases&#39;)</span>
<span class="sd">        axs[0].plot(data[peaks], altitude_agl[peaks], &#39;&gt;r&#39;, label=&#39;peaks&#39;)</span>
<span class="sd">        axs[0].plot(data[tops], altitude_agl[tops], &#39;^k&#39;, label=&#39;tops&#39;)</span>
<span class="sd">        </span>
<span class="sd">        #set axis</span>
<span class="sd">        axs[0].set_ylim([ymin, ymax])</span>
<span class="sd">        #axs[0].set_xlim([-20000,20000])</span>
<span class="sd">        axs[0].legend()</span>

<span class="sd">        #derivative on the right</span>
<span class="sd">        axs[1].plot(ddata_dz, altitude_agl, &#39;b&#39;, label=&#39;first derivative&#39;)</span>
<span class="sd">        axs[1].plot(ddata_dz[bases], altitude_agl[bases], &#39;&lt;g&#39;, label=&#39;bases&#39;)</span>
<span class="sd">        axs[1].plot(ddata_dz[peaks], altitude_agl[peaks], &#39;&gt;r&#39;, label=&#39;peaks&#39;)</span>
<span class="sd">        </span>
<span class="sd">        axs[1].set_ylim([ymin, ymax])</span>
<span class="sd">        axs[1].legend()</span>
<span class="sd">        #set title</span>
<span class="sd">        fig.suptitle(t,weight=&#39;bold&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;bases&#39;</span><span class="p">:</span> <span class="n">bases</span><span class="p">,</span>
            <span class="s1">&#39;peaks&#39;</span><span class="p">:</span> <span class="n">peaks</span><span class="p">,</span>
            <span class="s1">&#39;tops&#39;</span><span class="p">:</span> <span class="n">tops</span><span class="p">,</span>
        <span class="p">}</span>



    <span class="c1">#we work on profiles averaged in time to reduce the noise</span>
    <span class="n">rcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_avg</span><span class="p">(</span><span class="n">time_avg</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attenuated_backscatter_0</span>

    <span class="n">clouds_bases</span><span class="p">,</span> <span class="n">clouds_peaks</span><span class="p">,</span> <span class="n">clouds_tops</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)),</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;clouds&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))):</span>
        <span class="n">clouds</span> <span class="o">=</span> <span class="n">_detect_clouds_from_rcs</span><span class="p">(</span><span class="n">rcs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">thr_noise</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">)</span>
        
        <span class="c1">#store info in 2D array</span>
        <span class="n">clouds_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;bases&#39;</span><span class="p">])</span>
        <span class="n">clouds_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;peaks&#39;</span><span class="p">])</span>
        <span class="n">clouds_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;tops&#39;</span><span class="p">])</span>
    
    <span class="c1">#creates dataarrays</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_bases&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">clouds_bases</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
        <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Mask - Base height of clouds&quot;</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
            <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
            <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
            <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">clouds_peaks</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
        <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Mask - Peak height of clouds&quot;</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
            <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
            <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
            <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_tops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">clouds_tops</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
        <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Mask - Top height of clouds&quot;</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
            <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
            <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
            <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span></div>

<span class="k">def</span> <span class="nf">_main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">aprofiles</span> <span class="k">as</span> <span class="nn">apro</span>
    <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;examples/data/E-PROFILE/L2_0-20000-001492_A20210909.nc&quot;</span>
    <span class="n">profiles</span> <span class="o">=</span> <span class="n">apro</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">ReadProfiles</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c1">#basic corrections</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">extrapolate_below</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="mf">150.</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#profiles.desaturate_below(z=4000., inplace=True)</span>
    
    <span class="c1">#detection</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">clouds</span><span class="p">(</span><span class="n">zmin</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">thr_noise</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">show_clouds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1e1</span><span class="p">)</span>
    <span class="c1">#plot single profile</span>
    <span class="n">datetime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;2021-09-09T14:00:00&#39;</span><span class="p">)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">datetime</span><span class="o">=</span><span class="n">datetime</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">zmax</span><span class="o">=</span><span class="mi">12000</span><span class="p">,</span> <span class="n">show_clouds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">_main</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Augustin Mortier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>