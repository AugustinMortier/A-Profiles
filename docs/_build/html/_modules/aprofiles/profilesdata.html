<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aprofiles.profilesdata &mdash; A-Profiles  documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> A-Profiles
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">A-Profiles</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>aprofiles.profilesdata</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aprofiles.profilesdata</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1"># @author Augustin Mortier</span>
<span class="c1"># @email augustinm@met.no</span>
<span class="c1"># @desc A-Profiles - ProfilesData class</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span> <span class="nn">aprofiles</span> <span class="k">as</span> <span class="nn">apro</span>


<div class="viewcode-block" id="ProfilesData"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData">[docs]</a><span class="k">class</span> <span class="nc">ProfilesData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class representing profiles data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;Data attribute (instance of :class:`xarray.Dataset`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> 
    
    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span> 
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong data type: an xarray Dataset is expected.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">altitude</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the closest index of the ProfilesData vertical dimension to a given AGL altitude</span>

<span class="sd">        Args:</span>
<span class="sd">            altitude (float): in m, altitude AGL to look for</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Closest index of the vertical dimension to the given altitude AGL</span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">altitude_asl</span> <span class="o">=</span> <span class="n">altitude</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">station_altitude</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">altitude_asl</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the resolution of a given dimension. Support &#39;altitude&#39; and &#39;time&#39;. The altitude resolution is given in meters, while the time resolution is given in seconds.</span>

<span class="sd">        Args:</span>
<span class="sd">            which ({&#39;altitude&#39;,&#39;time&#39;}): Defaults to `&#39;altitude&#39;`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: resolution, in m (if which==&#39;altitude&#39;) or in s (if which==&#39;time&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;altitude&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[s]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_lowest_clouds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#returns an array of the altitude (in m, ASL) of the lowest cloud for each timestamp</span>

        <span class="k">def</span> <span class="nf">get_true_indexes</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
        <span class="c1">#mask: list of Bool</span>
        <span class="c1">#returns a list indexes where the mask is True</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
            
        <span class="n">lowest_clouds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">i_clouds</span> <span class="o">=</span> <span class="n">get_true_indexes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clouds_bases</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_clouds</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">lowest_clouds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i_clouds</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lowest_clouds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lowest_clouds</span>


<div class="viewcode-block" id="ProfilesData.snr"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.snr">[docs]</a>    <span class="k">def</span> <span class="nf">snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that calculates the Signal to Noise Ratio. </span>

<span class="sd">        Args:</span>
<span class="sd">            - var (str, optional): Variable of the DataArray to calculate the SNR from. Defaults to &#39;attenuated_backscatter_0&#39;.</span>
<span class="sd">            - step (int, optional): Number of steps around we calculate the SNR for a given altitude. Defaults to 4.</span>
<span class="sd">            - verbose (bool, optional): Verbose mode. Defaults to `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object with additional :class:`xarray.DataArray` &#39;snr&#39;.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This calculation is relatively heavy in terms of calculation costs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_1D_snr</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
                <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">step</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">step</span><span class="p">)</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gates</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">std</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">snr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="o">/</span><span class="n">std</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">snr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span>
        
        <span class="n">snr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;snr&#39;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))):</span>
            <span class="n">snr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_1D_snr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">step</span><span class="p">))</span>

        
        <span class="c1">#creates dataarrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;snr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">snr</span><span class="p">),</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Signal to Noise Ratio&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">step</span>
            <span class="p">)</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="ProfilesData.gaussian_filter"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.gaussian_filter">[docs]</a>    <span class="k">def</span> <span class="nf">gaussian_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies a 2D gaussian filter in order to reduce high frequency noise.</span>

<span class="sd">        Args:</span>
<span class="sd">            - sigma (scalar or sequence of scalars, optional): Standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes. Defaults to `0.25`.</span>
<span class="sd">            - var (str, optional): variable name of the Dataset to be processed. Defaults to `&#39;attenuated_backscatter_0&#39;`.</span>
<span class="sd">            - inplace (bool, optional): if True, replace the variable, else use a copy. Defaults to `False`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>

        <span class="c1">#apply gaussian filter</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">filtered_data</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copied_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">copied_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">filtered_data</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copied_dataset</span>
        <span class="c1">#add attribute</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gaussian filter&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">sigma</span>
        <span class="k">return</span> <span class="n">new_dataset</span></div>

        
<div class="viewcode-block" id="ProfilesData.time_avg"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.time_avg">[docs]</a>    <span class="k">def</span> <span class="nf">time_avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minutes</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span>  <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rolling meadian on the time dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            - minutes (float): Number of minutes to average over.</span>
<span class="sd">            - var (str, optional): variable of the Dataset to be processed. Defaults to `&#39;attenuated_backscatter_0&#39;`.</span>
<span class="sd">            - inplace (bool, optional): if True, replace the variable, else use a copy. Defaults to `False`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1">#time conversion from minutes to seconds</span>
        <span class="n">t_avg</span> <span class="o">=</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span>
        <span class="c1">#time resolution in profiles data in seconds</span>
        <span class="n">dt_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_resolution</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
        <span class="c1">#number of timestamps to be to averaged</span>
        <span class="n">nt_avg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="nb">round</span><span class="p">(</span><span class="n">t_avg</span><span class="o">/</span><span class="n">dt_s</span><span class="p">)])</span>
        <span class="c1">#rolling median</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">rcs</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">nt_avg</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">filtered_data</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copied_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">copied_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">filtered_data</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copied_dataset</span>
        <span class="c1">#add attribute</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time averaged (minutes)&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">minutes</span>
        <span class="k">return</span> <span class="n">new_dataset</span></div>


<div class="viewcode-block" id="ProfilesData.extrapolate_below"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.extrapolate_below">[docs]</a>    <span class="k">def</span> <span class="nf">extrapolate_below</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cst&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for extrapolating lowest layers below a certain altitude. This is of particular intrest for instruments subject to After Pulse effect, with saturated signal in the lowest layers.</span>
<span class="sd">        We recommend to use a value of zmin=150m due to random values often found below that altitude which perturbs the clouds detection.</span>

<span class="sd">        Args:</span>
<span class="sd">            - var (str, optional): variable of the Dataset to be processed. Defaults to `&#39;attenuated_backscatter_0&#39;`.</span>
<span class="sd">            - zmin (float, optional): Altitude (in m, AGL) below which the signal is extrapolated. Defaults to `0`.</span>
<span class="sd">            - method ({&#39;cst&#39;, &#39;lin&#39;}, optional): Method to be used for extrapolation of lowest layers. Defaults to `&#39;cst&#39;`.</span>
<span class="sd">            - inplace (bool, optional): if True, replace the variable. Defaults to `False`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#get index of zmin</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">zmin</span><span class="p">)</span>
        
        <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cst&#39;</span><span class="p">:</span>
            <span class="c1">#get values at imin</span>
            <span class="n">data_zmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">imin</span><span class="p">]</span>
            <span class="c1">#generates ones matrice with time/altitude dimension to fill up bottom</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span><span class="n">imin</span><span class="p">))</span>
            <span class="c1">#replace values</span>
            <span class="n">filling_matrice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ones</span><span class="p">),</span><span class="n">data_zmin</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lin&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Linear extrapolation is not implemented yet&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected string: lin or cst&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">filling_matrice</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copied_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">copied_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">filling_matrice</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copied_dataset</span>
        
        <span class="c1">#add attributes</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;extrapolation_low_layers_altitude_agl&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">zmin</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;extrapolation_low_layers_method&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">method</span>
        <span class="k">return</span> <span class="n">new_dataset</span></div>


    
<div class="viewcode-block" id="ProfilesData.range_correction"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.range_correction">[docs]</a>    <span class="k">def</span> <span class="nf">range_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that corrects the solid angle effect (1/z2) which makes that the backscatter beam more unlikely to be detected with the square of the altitude.</span>

<span class="sd">        Args:</span>
<span class="sd">            - var (str, optional): variable of the Dataset to be processed. Defaults to `&#39;attenuated_backscatter_0&#39;`.</span>
<span class="sd">            - inplace (bool, optional): if True, replace the variable. Defaults to `False`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#for the altitude correction, must one use the altitude above the ground level</span>
        <span class="n">z_agl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">station_altitude</span><span class="o">.</span><span class="n">data</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">range_corrected_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">z_agl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">range_corrected_data</span>
            <span class="n">new_profiles_data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copied_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">copied_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">range_corrected_data</span>
            <span class="n">new_profiles_data</span> <span class="o">=</span> <span class="n">copied_dataset</span>

        <span class="c1">#add attribute</span>
        <span class="n">new_profiles_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;range correction&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="c1">#remove units</span>
        <span class="n">new_profiles_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">return</span> <span class="n">new_profiles_data</span></div>



<div class="viewcode-block" id="ProfilesData.foc"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.foc">[docs]</a>    <span class="k">def</span> <span class="nf">foc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cloud_base&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">z_snr</span><span class="o">=</span><span class="mf">2000.</span><span class="p">,</span> <span class="n">min_snr</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">zmin_cloud</span><span class="o">=</span><span class="mf">200.</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;Detects fog or condensation.</span>

<span class="sd">        Args:</span>
<span class="sd">            - method ({&#39;cloud_base&#39;, &#39;snr&#39;}, optional): Defaults to `&#39;cloud_base&#39;`.</span>
<span class="sd">            - var (str, optional). Used for &#39;snr&#39; method. Variable from ProfilesData to calculate SNR from. Defaults to `&#39;attenuated_backscatter_0&#39;`.</span>
<span class="sd">            - z_snr (float, optional): Used for &#39;snr&#39; method. Altitude AGL (in m) at which we calculate the SNR. Defaults to `2000.`.</span>
<span class="sd">            - min_snr (float, optional): Used for &#39;snr&#39; method. Minimum SNR under which the profile is considered as containing fog or condensation. Defaults to `2.`.</span>
<span class="sd">            - zmin_cloud (float, optional): Used for &#39;cloud_base&#39; method. Altitude AGL (in m) below which a cloud base height is considered a fog or condensation situation. Defaults to `200.`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object with additional :class:`xarray.DataArray` &#39;foc&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_detect_fog_from_cloud_base_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zmin_cloud</span><span class="p">):</span>
            <span class="c1">#returns a bool list with True where fog/condensation cases</span>
            <span class="c1">#if the base of the first cloud (given by the constructor) is below </span>
            <span class="n">first_cloud_base_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cloud_base_height</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#condition</span>
            <span class="n">foc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">zmin_cloud</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">first_cloud_base_height</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">foc</span>
        
        <span class="k">def</span> <span class="nf">_detect_fog_from_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_snr</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">):</span>
            <span class="c1">#returns a bool list with True where fog/condensation cases</span>

            <span class="k">def</span> <span class="nf">_snr_at_iz</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
                <span class="c1">#calculates the snr from array at iz around step points</span>
                <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iz</span><span class="o">-</span><span class="n">step</span><span class="p">,</span><span class="n">iz</span><span class="o">+</span><span class="n">step</span><span class="p">)</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gates</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">std</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">mean</span><span class="o">/</span><span class="n">std</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>

            <span class="c1">#calculates snr at z_snr</span>
            <span class="n">iz_snr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">z_snr</span><span class="p">)</span>
            <span class="c1">#calculates snr at each timestamp</span>
            <span class="n">snr</span> <span class="o">=</span> <span class="p">[</span><span class="n">_snr_at_iz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">iz_snr</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))]</span>
            <span class="c1">#condition</span>
            <span class="n">foc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">min_snr</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">snr</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">foc</span>


        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;cloud_base&#39;</span><span class="p">:</span>
            <span class="n">foc</span> <span class="o">=</span> <span class="n">_detect_fog_from_cloud_base_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zmin_cloud</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;SNR&#39;</span><span class="p">:</span>
            <span class="n">foc</span> <span class="o">=</span> <span class="n">_detect_fog_from_snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_snr</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">)</span>

        <span class="c1">#creates dataarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;foc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">foc</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Fog or condensation mask.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>
    
    
<div class="viewcode-block" id="ProfilesData.clouds"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.clouds">[docs]</a>    <span class="k">def</span> <span class="nf">clouds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_avg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thr_noise</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">min_snr</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Module for clouds detection.</span>

<span class="sd">        Args:</span>
<span class="sd">            - time_avg (int, optional): in minutes, the time during which we aggregates the profiles before detecting clouds. Defaults to `1`.</span>
<span class="sd">            - zmin (float, optional): altitude AGL, in m, above which we look for clouds. Defaults to `0`. We recommend using the same value as used in the extrapolation_low_layers method.</span>
<span class="sd">            - thr_noise (float, optional): threshold used in the test to determine if a couple (base,peak) is significant: data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z). Defaults to `5`.</span>
<span class="sd">            - thr_clouds (float, optional): threshold used to discriminate aerosol from clouds: data[peak(z)] / data[base(z)] &gt;= thr_clouds. Defaults to `4`.</span>
<span class="sd">            - min_snr (float, optional). Minimum SNR required at the clouds peak value to consider the cloud as valid. Defaults to `0`.</span>
<span class="sd">            - verbose (bool, optional): verbose mode. Defaults to `False`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object with additional :class:`xarray.DataArray`: &#39;clouds_bases&#39;, &#39;clouds_peaks&#39;, and &#39;clouds_tops&#39;. &#39;clouds_bases&#39; correspond to the bases of the clouds. &#39;clouds_peaks&#39; correspond to the maximum of backscatter signal measured in the clouds. &#39;clouds_tops&#39; correspond to the top of the cloud if the beam crosses the cloud. If not, the top corresponds to the first value where the signal becomes lower than the one measured at the base of the cloud.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_detect_clouds_from_rcs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">thr_noise</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">):</span>
            <span class="c1">#data: 1D range corrected signal (rcs)</span>
            <span class="c1">#zmin: altitude AGL, in m, above which we detect clouds</span>
            <span class="c1">#thr_noise: threshold used in the test to determine if a couple (base,peak) is significant: data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z)</span>
            <span class="c1">#thr_clouds: threshold used to discriminate aerosol from clouds: data[peak(z)] / data[base(z)] &gt;= thr_clouds</span>
            <span class="c1">#min_snr: minimum SNR required at the clouds peak value to consider the cloud as valid. Defaults to 2.</span>
            
            <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
            <span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">uniform_filter1d</span>

            <span class="c1">#some useful functions:</span>
            <span class="k">def</span> <span class="nf">get_indexes</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="c1">#mask: list of Bool</span>
                <span class="c1">#returns a list indexes where the mask is True</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
            
            <span class="k">def</span> <span class="nf">make_mask</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">indexes_where_True</span><span class="p">):</span>
                <span class="c1">#length: int: length of the mask</span>
                <span class="c1">#indexes_where_true: list</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">length</span><span class="p">)])</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">indexes_where_True</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes_where_True</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">mask</span>
            
            <span class="k">def</span> <span class="nf">_snr_at_iz</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
                <span class="c1">#calculates the snr from array at iz around step points</span>
                <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iz</span><span class="o">-</span><span class="n">step</span><span class="p">,</span><span class="n">iz</span><span class="o">+</span><span class="n">step</span><span class="p">)</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gates</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">std</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">mean</span><span class="o">/</span><span class="n">std</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span>

            <span class="c1">#0. rolling average</span>
            <span class="n">avg_data</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


            <span class="c1">#1. first derivative</span>
            <span class="n">ddata_dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


            <span class="c1">#2. identifies peaks and base by checking the sign changes of the derivative</span>
            <span class="n">sign_changes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">ddata_dz</span><span class="p">),</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">all_bases</span> <span class="o">=</span> <span class="n">sign_changes</span><span class="o">==</span><span class="mi">2</span>
            <span class="n">all_peaks</span> <span class="o">=</span> <span class="n">sign_changes</span><span class="o">==-</span><span class="mi">2</span>
            <span class="c1">#limit to bases above zmin</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">zmin</span><span class="p">)</span>
            <span class="n">all_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]))]</span>
            <span class="n">all_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]))]</span>
            
            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">)</span>


            <span class="c1">#3. the signal should start with a base</span>
            <span class="k">if</span> <span class="n">i_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1">#set base as the minimum between peak and n gates under</span>
                <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">i_base</span> <span class="o">=</span> <span class="n">gates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">gates</span><span class="p">[</span><span class="n">gates</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]]])]</span>
                <span class="k">if</span> <span class="n">i_base</span><span class="o">&gt;=</span><span class="n">imin</span><span class="p">:</span>
                    <span class="n">all_bases</span><span class="p">[</span><span class="n">i_base</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#update indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_bases</span><span class="p">)</span>

            
            <span class="c1">#4. keeps significant couples (base,peak)</span>
            <span class="c1"># a layer can be considered as a proper layer if the difference of signal between the peak and the base is significant (larger than the noise level)</span>
            <span class="c1"># noise evaluation (using a high passing frequency filter)</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="c1">#rolling average of the noise</span>
            <span class="n">avg_abs_noise</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">noise</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="c1">#make sure we have as many peaks as bases</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">):</span>
                <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)])</span>
                <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_len</span><span class="p">]</span>
                <span class="n">i_bases</span> <span class="o">=</span> <span class="n">i_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_len</span><span class="p">]</span>
                

            <span class="c1"># data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z)</span>
            <span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span> <span class="o">=</span> <span class="n">all_bases</span><span class="p">,</span> <span class="n">all_peaks</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
                <span class="c1">#data_around_peak = np.mean(data[i_peaks[i]-1:i_peaks[i]+1])</span>
                <span class="c1">#data_around_base = np.mean(data[i_bases[i]-1:i_bases[i]+1])</span>
                <span class="n">data_around_peak</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">data_around_base</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">data_around_peak</span> <span class="o">-</span> <span class="n">data_around_base</span> <span class="o">&lt;=</span> <span class="n">thr_noise</span> <span class="o">*</span> <span class="n">avg_abs_noise</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>


            <span class="c1">#5. make sure we finish by a peak: remove last base </span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">):</span>
                <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">i_bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1">#6. distinction between aerosol and clouds</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
                <span class="n">data_around_peak</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">data_around_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">data_around_peak</span> <span class="o">-</span> <span class="n">data_around_base</span><span class="p">)</span> <span class="o">/</span> <span class="n">data_around_base</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thr_clouds</span><span class="p">:</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
            

            <span class="c1">#7. find tops of clouds layers</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
            <span class="c1"># conditions: look for bases above i_peaks[i], and data[top[i]] &lt;= data[base[i]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
                <span class="n">mask_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="o">&lt;</span><span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">mask_altitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
                <span class="n">mask_altitude</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1">#the top is the first value that corresponds to the intersection of the two masks</span>
                <span class="n">cross_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask_value</span><span class="p">,</span> <span class="n">mask_altitude</span><span class="p">)</span>
                <span class="n">i_cross_mask</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">cross_mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_cross_mask</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                        <span class="c1">#print(&#39;top already found. remove current layer&#39;)</span>
                        <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#print(&#39;found top at &#39;,i_cross_mask[0], &#39;for base &#39;,i_bases[i])</span>
                        <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print(&#39;no top found for base&#39;,i_bases[i])</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
            <span class="n">i_tops</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>

            
            <span class="c1">#8. merge layers: just focus on bases and tops</span>
            <span class="c1">#drop layer if base of next layer below top of current layer top of current layer</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">i_bases</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">i_tops</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            
            <span class="c1">#9. finds peaks as maximum value between base and top</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">))]</span>


            <span class="c1">#10. check snr at peak levels</span>
            <span class="n">remove_bases</span><span class="p">,</span> <span class="n">remove_peaks</span><span class="p">,</span> <span class="n">remove_tops</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">_snr_at_iz</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">min_snr</span><span class="p">:</span>
                    <span class="n">remove_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">remove_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">remove_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># remove indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_base</span> <span class="k">for</span> <span class="n">i_base</span> <span class="ow">in</span> <span class="n">i_bases</span> <span class="k">if</span> <span class="n">i_base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_bases</span><span class="p">]</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_peak</span> <span class="k">for</span> <span class="n">i_peak</span> <span class="ow">in</span> <span class="n">i_peaks</span> <span class="k">if</span> <span class="n">i_peak</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_peaks</span><span class="p">]</span>
            <span class="n">i_tops</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_top</span> <span class="k">for</span> <span class="n">i_top</span> <span class="ow">in</span> <span class="n">i_tops</span> <span class="k">if</span> <span class="n">i_top</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_tops</span><span class="p">]</span>


            <span class="c1">#11. rebuild masks from indexes</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_bases</span><span class="p">)</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_peaks</span><span class="p">)</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_tops</span><span class="p">)</span>
            
            
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            #some plotting</span>
<span class="sd">            fig, axs = plt.subplots(1,2,figsize=(10,10))</span>
<span class="sd">            </span>
<span class="sd">            ymin, ymax = 000, 15000</span>
<span class="sd">            altitude_agl = profiles.data.altitude.data - profiles.data.station_altitude.data</span>
<span class="sd">            </span>
<span class="sd">            #signal on the left</span>
<span class="sd">            axs[0].plot(data, altitude_agl, &#39;b&#39;, label=&#39;rcs&#39;)</span>
<span class="sd">            axs[0].plot(avg_data, altitude_agl, &#39;c&#39;, label=&#39;rcs&#39;)</span>
<span class="sd">            axs[0].plot(avg_abs_noise,altitude_agl,&#39;:b&#39;, label=&#39;noise level&#39;)</span>
<span class="sd">            axs[0].plot(avg_abs_noise*thr_noise,altitude_agl,&#39;:b&#39;, label=&#39;noise level * {}&#39;.format(thr_noise))</span>
<span class="sd">            axs[0].plot(data[bases], altitude_agl[bases], &#39;&lt;g&#39;, label=&#39;bases&#39;)</span>
<span class="sd">            axs[0].plot(data[peaks], altitude_agl[peaks], &#39;&gt;r&#39;, label=&#39;peaks&#39;)</span>
<span class="sd">            axs[0].plot(data[tops], altitude_agl[tops], &#39;^k&#39;, label=&#39;tops&#39;)</span>
<span class="sd">            </span>
<span class="sd">            #set axis</span>
<span class="sd">            axs[0].set_ylim([ymin, ymax])</span>
<span class="sd">            #axs[0].set_xlim([-20000,20000])</span>
<span class="sd">            axs[0].legend()</span>

<span class="sd">            #derivative on the right</span>
<span class="sd">            axs[1].plot(ddata_dz, altitude_agl, &#39;b&#39;, label=&#39;first derivative&#39;)</span>
<span class="sd">            axs[1].plot(ddata_dz[bases], altitude_agl[bases], &#39;&lt;g&#39;, label=&#39;bases&#39;)</span>
<span class="sd">            axs[1].plot(ddata_dz[peaks], altitude_agl[peaks], &#39;&gt;r&#39;, label=&#39;peaks&#39;)</span>
<span class="sd">            </span>
<span class="sd">            axs[1].set_ylim([ymin, ymax])</span>
<span class="sd">            axs[1].legend()</span>
<span class="sd">            #set title</span>
<span class="sd">            fig.suptitle(t,weight=&#39;bold&#39;)</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;bases&#39;</span><span class="p">:</span> <span class="n">bases</span><span class="p">,</span>
                <span class="s1">&#39;peaks&#39;</span><span class="p">:</span> <span class="n">peaks</span><span class="p">,</span>
                <span class="s1">&#39;tops&#39;</span><span class="p">:</span> <span class="n">tops</span><span class="p">,</span>
            <span class="p">}</span>


        <span class="c1">#make sure some corrections have been done before</span>
        <span class="c1">#if &#39;range correction&#39; not in self.data.attenuated_backscatter_0.attrs or not self.data.attenuated_backscatter_0.attrs[&#39;range correction&#39;]:</span>
        <span class="c1">#    print(&#39;The range correction has not been applied to the backscatter profiles&#39;)</span>
        <span class="c1">#    pass</span>

        <span class="c1">#we work on profiles averaged in time to reduce the noise</span>
        <span class="n">rcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_avg</span><span class="p">(</span><span class="n">time_avg</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attenuated_backscatter_0</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;clouds&#39;</span><span class="p">)</span>
        
        <span class="n">clouds_bases</span><span class="p">,</span> <span class="n">clouds_peaks</span><span class="p">,</span> <span class="n">clouds_tops</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))):</span>
            <span class="n">clouds</span> <span class="o">=</span> <span class="n">_detect_clouds_from_rcs</span><span class="p">(</span><span class="n">rcs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">thr_noise</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">)</span>
            
            <span class="c1">#store info in 2D array</span>
            <span class="n">clouds_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;bases&#39;</span><span class="p">])</span>
            <span class="n">clouds_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;peaks&#39;</span><span class="p">])</span>
            <span class="n">clouds_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;tops&#39;</span><span class="p">])</span>
        
        <span class="c1">#creates dataarrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_bases&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">clouds_bases</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Mask - Base height of clouds&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
                <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">clouds_peaks</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Mask - Peak height of clouds&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
                <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_tops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">clouds_tops</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Mask - Top height of clouds&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
                <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ProfilesData.pbl"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.pbl">[docs]</a>    <span class="k">def</span> <span class="nf">pbl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_avg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">zmax</span><span class="o">=</span><span class="mf">3000.</span><span class="p">,</span> <span class="n">wav_width</span><span class="o">=</span><span class="mf">200.</span><span class="p">,</span> <span class="n">under_clouds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_snr</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detects Planetary Boundary Layer Height between zmin and zmax using convolution with a wavelet.</span>

<span class="sd">        Args:</span>
<span class="sd">            - time_avg (int, optional): in minutes, the time during which we aggregate the profiles before detecting the PBL. Defaults to `1`.</span>
<span class="sd">            - zmin (float, optional): maximum altitude AGL, in m, for retrieving the PBL. Defaults to `100`.</span>
<span class="sd">            - zmin (float, optional): minimum altitude AGL, in m, for retrieving the PBL. Defaults to `3000`.</span>
<span class="sd">            - wav_width (float, optional): Width of the wavelet used in the convolution, in m. Defaults to `200`.</span>
<span class="sd">            - under_clouds (bool, optional): If True, and if clouds detection have been called before, force the PBL to be found below the first cloud detected in the profile. Defaults to `True`.</span>
<span class="sd">            - min_snr (float, optional). Minimum SNR at the retrieved PBL height required to return a valid value. Defaults to `2.`.</span>
<span class="sd">            - verbose (bool, optional): verbose mode. Defaults to `False`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object with additional :class:`xarray.DataArray` &#39;pbl&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>        

        <span class="k">def</span> <span class="nf">_snr_at_iz</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
            <span class="c1">#calculates the snr from array at iz around step points</span>
            <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">iz</span><span class="o">-</span><span class="n">step</span><span class="p">,</span><span class="n">iz</span><span class="o">+</span><span class="n">step</span><span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gates</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">indexes</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">std</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mean</span><span class="o">/</span><span class="n">std</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>


        <span class="k">def</span> <span class="nf">_detect_pbl_from_rcs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">wav_width</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">):</span>
            <span class="c1">#detect pbl from range corrected signal between zmin and zmax using convolution with a wavelet..</span>

            <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

            <span class="c1">#define wavelet with constant width</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">wav_width</span> <span class="c1">#in meter</span>
            <span class="n">wav</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ricker</span><span class="p">(</span><span class="n">npoints</span><span class="p">,</span> <span class="n">width</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_resolution</span><span class="p">(</span><span class="s1">&#39;altitude&#39;</span><span class="p">))</span>

            <span class="c1">#simple convolution</span>
            <span class="n">convolution</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wav</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

            <span class="c1">#the PBL is the maximum of the convolution</span>
            <span class="c1">#sets to nan outside of PBL search range</span>
            <span class="n">convolution</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">zmin</span><span class="p">):]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">convolution</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">zmax</span><span class="p">):]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">i_pbl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">convolution</span><span class="p">))</span>
            
            <span class="c1">#calculates SNR</span>
            <span class="n">snr</span> <span class="o">=</span>  <span class="n">_snr_at_iz</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i_pbl</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">snr</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i_pbl</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1">#we work on profiles averaged in time to reduce the noise</span>
        <span class="n">rcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_avg</span><span class="p">(</span><span class="n">time_avg</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attenuated_backscatter_0</span>


        <span class="c1">#if under_clouds, check if clouds_bases is available</span>
        <span class="k">if</span> <span class="n">under_clouds</span> <span class="ow">and</span> <span class="s1">&#39;clouds_bases&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span><span class="p">):</span>
            <span class="n">lowest_clouds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowest_clouds</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">under_clouds</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;clouds_bases&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;under_clouds parameter sets to True (defaults value) when the clouds detection has not been applied to ProfileData object.&quot;</span><span class="p">)</span>
            <span class="n">lowest_clouds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lowest_clouds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pbl&#39;</span><span class="p">)</span>

        <span class="n">pbl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))):</span>
            <span class="n">lowest_cloud_agl</span> <span class="o">=</span> <span class="n">lowest_clouds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">station_altitude</span><span class="o">.</span><span class="n">data</span>
            <span class="n">pbl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_detect_pbl_from_rcs</span><span class="p">(</span><span class="n">rcs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="n">zmax</span><span class="p">,</span> <span class="n">lowest_cloud_agl</span><span class="p">]),</span> <span class="n">wav_width</span><span class="p">,</span> <span class="n">min_snr</span><span class="p">))</span>

         <span class="c1">#creates dataarrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pbl&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">pbl</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Planetary Boundary Layer Height, ASL&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">zmin</span><span class="o">=</span><span class="n">zmin</span><span class="p">,</span>
                <span class="n">zmax</span><span class="o">=</span><span class="n">zmax</span>
            <span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="ProfilesData.klett_inversion"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.klett_inversion">[docs]</a>    <span class="k">def</span> <span class="nf">klett_inversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_avg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mf">4000.</span><span class="p">,</span> <span class="n">zmax</span><span class="o">=</span><span class="mf">6000.</span><span class="p">,</span> <span class="n">under_clouds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">,</span> <span class="n">apriori</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;lr&#39;</span><span class="p">:</span> <span class="mf">50.</span><span class="p">},</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Klett inversion using an apriori.</span>

<span class="sd">        Args:</span>
<span class="sd">            - time_avg (int, optional): in minutes, the time during which we aggregate the profiles before detecting the PBL. Defaults to `1`.</span>
<span class="sd">            - zmin (float, optional): minimum altitude AGL, in m, for looking for the initialization altitude. Defaults to `4000.`.</span>
<span class="sd">            - zmax (float, optional): maximum altitude AGL, in m, for looking for the initialization altitude. Defaults to `6000.`.</span>
<span class="sd">            - under_clouds (bool, optional): If True, and if clouds detection have been called before, force the initialization altitude to be found below the first cloud detected in the profile. Defaults to `True`.</span>
<span class="sd">            - method ({&#39;backward&#39;, &#39;forward&#39;}, optional). Defaults to `&#39;forward&#39;`.</span>
<span class="sd">            - apriori (dict, optional). A Priori value to be used to constrain the inversion. Valid keys: &#39;lr&#39; (Lidar Ratio, in sr) and &#39;aod&#39; (unitless). Defaults to `{&#39;lr&#39;: 50}`.</span>
<span class="sd">            - remove_outliers (bool, optional). Remove profiles considered as outliers based on aod calculation ([&gt;0, &lt;1]). Defaults to `False` (while development. to be changed afterwards).</span>
<span class="sd">            - verbose (bool, optional): verbose mode. Defaults to `False`.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: :ref:`ProfilesData` object with additional :class:`xarray.DataArray` `ext`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_iref</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">):</span>
            <span class="c1">#function that returns best index to be used for initializing the Klett inversion</span>
    
            <span class="c1">#it is important to copy the data not to modify it outside of the function</span>
            <span class="kn">import</span> <span class="nn">copy</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1">#check if imin below imax</span>
            <span class="k">if</span> <span class="n">imin</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">:</span>
                <span class="c1">#limit from imin to imax</span>
                <span class="n">maxdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxdata</span>
                <span class="n">data</span><span class="p">[</span><span class="n">imax</span><span class="p">:]</span> <span class="o">=</span> <span class="n">maxdata</span>
                
                <span class="c1">#running average</span>
                <span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">uniform_filter1d</span>
                <span class="n">avg_data</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">avg_data</span><span class="p">)):</span>
                    <span class="c1">#get minimum from the averaged signal</span>
                    <span class="n">ilow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">avg_data</span><span class="p">)</span>

                    <span class="c1">#around minimum, get index of closest signal to average signal</span>
                    <span class="n">n_around_min</span> <span class="o">=</span> <span class="mi">3</span>
                    <span class="n">iclose</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ilow</span><span class="o">-</span><span class="n">n_around_min</span><span class="p">:</span><span class="n">ilow</span><span class="o">+</span><span class="n">n_around_min</span><span class="p">]</span> <span class="o">-</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">ilow</span><span class="o">-</span><span class="n">n_around_min</span><span class="p">:</span><span class="n">ilow</span><span class="o">+</span><span class="n">n_around_min</span><span class="p">]))</span>
                    
                    <span class="k">return</span> <span class="n">ilow</span><span class="o">+</span><span class="n">iclose</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">klett</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">apriori</span><span class="p">,</span> <span class="n">rayleigh</span><span class="p">):</span>
            <span class="c1">#returns array of extinction in km-1</span>
            <span class="c1">#rayleigh: aprofiles.rayleigh.Rayleigh object</span>

            <span class="k">if</span> <span class="n">iref</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;aod&#39;</span> <span class="ow">in</span> <span class="n">apriori</span><span class="p">:</span>
                    <span class="c1">#search by dichotomy the LR that matches the apriori aod</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;AOD apriori is not implemented yet&#39;</span><span class="p">)</span>
                    <span class="n">lr_aer</span> <span class="o">=</span> <span class="mi">50</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#if we assume the LR, no need to minimize for matching aod </span>
                    <span class="n">lr_aer</span> <span class="o">=</span> <span class="n">apriori</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">]</span>
            
                <span class="kn">import</span> <span class="nn">math</span>
                <span class="n">lr_mol</span> <span class="o">=</span> <span class="mf">8.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.</span>
                    
                <span class="c1">#calculation</span>
                <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;backward&#39;</span><span class="p">:</span>
                    
                    <span class="c1">#vertical resolution</span>
                    <span class="n">dz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rayleigh</span><span class="o">.</span><span class="n">altitude</span><span class="p">))</span>

                    <span class="n">int1_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">((</span><span class="n">lr_aer</span><span class="o">-</span><span class="n">lr_mol</span><span class="p">)</span><span class="o">*</span><span class="n">rayleigh</span><span class="o">.</span><span class="n">backscatter</span><span class="p">[:</span><span class="n">iref</span><span class="p">]</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>
                    <span class="n">int1_b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">int1_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">int1_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iref</span><span class="p">)]</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">data</span><span class="p">[</span><span class="n">iref</span><span class="p">]))</span> <span class="o">+</span> <span class="n">int1_b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iref</span><span class="p">)]</span>

                    <span class="n">int2_a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">lr_aer</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">dz</span><span class="p">)</span>
                    <span class="n">int2_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">int2_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">int2_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iref</span><span class="p">)]</span>

                    <span class="c1">#initialize total backscatter</span>
                    <span class="n">back_aer_iref</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#m-1</span>
                    <span class="n">beta_tot_iref</span> <span class="o">=</span> <span class="n">rayleigh</span><span class="o">.</span><span class="n">backscatter</span><span class="p">[</span><span class="n">iref</span><span class="p">]</span> <span class="o">+</span> <span class="n">back_aer_iref</span>

                    <span class="c1">#total backscatter</span>
                    <span class="n">beta_tot</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">beta_tot_iref</span><span class="p">)</span><span class="o">+</span><span class="n">int2_b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iref</span><span class="p">)]</span>
                    <span class="c1">#aerosol backsatter (m-1.sr-1)</span>
                    <span class="n">beta_aer</span> <span class="o">=</span> <span class="n">beta_tot</span> <span class="o">-</span> <span class="n">rayleigh</span><span class="o">.</span><span class="n">backscatter</span><span class="p">[:</span><span class="n">iref</span><span class="p">]</span>
                    <span class="c1">#aerosol extinction (m-1)</span>
                    <span class="n">sigma_aer</span><span class="o">=</span><span class="n">lr_aer</span><span class="o">*</span><span class="n">beta_aer</span>
                    <span class="c1">#returns extinction in km-1 when valid, and np.nan elsewhere</span>
                    <span class="n">ext</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigma_aer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mf">1e3</span> <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">sigma_aer</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))]</span>

            <span class="k">return</span> <span class="n">ext</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        #we work on profiles averaged in time to reduce the noise</span>
<span class="sd">        rcs = self.data.attenuated_backscatter_0</span>
<span class="sd">        t_avg = time_avg * 60 #s</span>
<span class="sd">        #time resolution in profiles data</span>
<span class="sd">        dt_s = self._get_resolution(&#39;time&#39;)</span>
<span class="sd">        #number of timestamps to be averaged</span>
<span class="sd">        nt_avg = max([1,round(t_avg/dt_s)])</span>

<span class="sd">        #average profiles</span>
<span class="sd">        rcs_data = rcs.rolling(time=nt_avg, min_periods=1, center=True).median().data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#we work on profiles averaged in time to reduce the noise</span>
        <span class="n">rcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_avg</span><span class="p">(</span><span class="n">time_avg</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attenuated_backscatter_0</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        #if clouds detected, set to nan profiles where cloud is found below 4000m</span>
<span class="sd">        lowest_clouds = self._get_lowest_clouds()</span>
<span class="sd">        for i in range(len(self.data.time.data)):</span>
<span class="sd">            if lowest_clouds[i]&lt;=4000:</span>
<span class="sd">                rcs.data[i,:] = [np.nan for _ in rcs.data[i,:]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#if under_clouds, check if clouds_bases is available</span>
        <span class="k">if</span> <span class="n">under_clouds</span> <span class="ow">and</span> <span class="s1">&#39;clouds_bases&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span><span class="p">):</span>
            <span class="n">lowest_clouds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowest_clouds</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">under_clouds</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;clouds_bases&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;under_clouds parameter sets to True (defaults value) when the clouds detection has not been applied to ProfileData object.&quot;</span><span class="p">)</span>
            <span class="n">lowest_clouds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lowest_clouds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">))]</span>
        
        <span class="c1">#aerosol retrieval requires a molecular profile</span>
        <span class="n">altitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">l0_wavelength</span><span class="o">.</span><span class="n">data</span>
        <span class="n">rayleigh</span> <span class="o">=</span> <span class="n">apro</span><span class="o">.</span><span class="n">rayleigh</span><span class="o">.</span><span class="n">Rayleigh</span><span class="p">(</span><span class="n">altitude</span><span class="p">,</span> <span class="n">T0</span><span class="o">=</span><span class="mi">298</span><span class="p">,</span> <span class="n">P0</span><span class="o">=</span><span class="mi">1013</span><span class="p">,</span> <span class="n">wavelength</span><span class="o">=</span><span class="n">wavelength</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;klett&#39;</span><span class="p">)</span>

        <span class="c1">#aerosol inversion</span>
        <span class="n">ext</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">aod</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">aod_min</span><span class="p">,</span> <span class="n">aod_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">vertical_resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_resolution</span><span class="p">(</span><span class="s1">&#39;altitude&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))):</span>

            <span class="c1">#reference altitude</span>
            <span class="n">lowest_cloud_agl</span> <span class="o">=</span> <span class="n">lowest_clouds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">station_altitude</span><span class="o">.</span><span class="n">data</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">zmin</span><span class="p">)</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_from_altitude_AGL</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="n">zmax</span><span class="p">,</span> <span class="n">lowest_cloud_agl</span><span class="p">]))</span>
            <span class="n">iref</span> <span class="o">=</span> <span class="n">_iref</span><span class="p">(</span><span class="n">rcs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">)</span>

            <span class="c1">#klett inversion</span>
            <span class="n">_ext</span> <span class="o">=</span> <span class="n">klett</span><span class="p">(</span><span class="n">rcs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">iref</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">apriori</span><span class="p">,</span> <span class="n">rayleigh</span><span class="p">)</span>

            <span class="c1">#add aod and lr</span>
            <span class="k">if</span> <span class="s1">&#39;aod&#39;</span> <span class="ow">in</span> <span class="n">apriori</span><span class="p">:</span>
                    <span class="c1">#search by dichotomy the LR that matches the apriori aod</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;AOD apriori is not implemented yet&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#if we assume the LR, no need to minimize for matching aod</span>
                <span class="n">_lr</span> <span class="o">=</span> <span class="n">apriori</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">]</span>
                <span class="n">_aod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_ext</span><span class="p">)</span><span class="o">*</span><span class="n">vertical_resolution</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">_aod</span><span class="o">&lt;</span><span class="n">aod_min</span> <span class="ow">or</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">_aod</span><span class="o">&gt;</span><span class="n">aod_max</span><span class="p">:</span>
                    <span class="n">lr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">aod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_ext</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_lr</span><span class="p">)</span>
                    <span class="n">aod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_aod</span><span class="p">)</span>
                    <span class="n">ext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ext</span><span class="p">)</span>


        <span class="c1">#creates dataarrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ext&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Extinction Coefficient&quot;</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> Klett&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()),</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;km-1&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">zmin</span><span class="o">=</span><span class="n">zmin</span><span class="p">,</span>
                <span class="n">zmax</span><span class="o">=</span><span class="n">zmax</span><span class="p">,</span>
                <span class="n">apriori</span><span class="o">=</span><span class="n">apriori</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;aod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">aod</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Aerosol Optical Depth&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;Lidar Ratio&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;sr&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ProfilesData.plot"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">datetime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zref</span><span class="o">=</span><span class="s1">&#39;agl&#39;</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_fog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_pbl</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_clouds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plotting method. Quicklook or single profile.</span>

<span class="sd">        Args:</span>
<span class="sd">            - var (str, optional): Variable of ProfilesData.data Dataset to be plotted. Defaults to `&#39;attenuated_backscatter_0&#39;`.</span>
<span class="sd">            - datetime (np.datetime64, optional): if provided, plot the profile for closest time. If not, plot an image constructed on all profiles.Defaults to `None`.</span>
<span class="sd">            - zref (str, optional): Reference altitude. Expected values: &#39;agl&#39; (above ground level) or &#39;asl&#39; (above ea level). Defaults to &#39;agl&#39;</span>
<span class="sd">            - zmin (float, optional): Minimum altitude AGL (m). Defaults to `None`. If `None`, sets to minimum available altitude.</span>
<span class="sd">            - zmax (float, optional): Maximum altitude AGL (m). Defaults to `None`. If `None`, sets maximum available altitude.</span>
<span class="sd">            - vmin (float, optional): Minimum value. Defaults to `None`.</span>
<span class="sd">            - vmax (float, optional): Maximum value. Defaults to `None`. If `None`, calculates max from data.</span>
<span class="sd">            - log (bool, optional), Use logarithmic scale. Defaults to `False`.</span>
<span class="sd">            - show_fog (bool, optional): Add fog detection. Defaults to `False`.</span>
<span class="sd">            - show_pbl (bool, optional): Add PBL height. Defaults to `False`.</span>
<span class="sd">            - show_clouds (bool, optional): Add clouds detection. Defaults to `False`.</span>
<span class="sd">            - cmap (str, optional): Matplotlib colormap. Defaults to `&#39;coolwarm&#39;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#here, check the dimension. If the variable has only the time dimention, calls timeseries method</span>
        <span class="k">if</span> <span class="n">datetime</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="c1">#check dimension of var</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">apro</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">zref</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">show_fog</span><span class="p">,</span> <span class="n">show_pbl</span><span class="p">,</span> <span class="n">show_clouds</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">apro</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">timeseries</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">apro</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">zref</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">show_fog</span><span class="p">,</span> <span class="n">show_pbl</span><span class="p">,</span> <span class="n">show_clouds</span><span class="p">)</span></div></div>
    


<span class="k">def</span> <span class="nf">_main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">aprofiles</span> <span class="k">as</span> <span class="nn">apro</span>
    <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;data/e-profile/2021/09/08/L2_0-20000-006735_A20210908.nc&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;data/e-profile/2021/09/09/L2_0-20000-001492_A20210909.nc&quot;</span>
    <span class="n">profiles</span> <span class="o">=</span> <span class="n">apro</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">ReadProfiles</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c1">#profiles.quickplot(&#39;attenuated_backscatter_0&#39;, vmin=0, vmax=1, cmap=&#39;viridis&#39;)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">range_correction</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1e5</span><span class="p">)</span>

    <span class="n">profiles</span><span class="o">.</span><span class="n">extrapolate_below</span><span class="p">(</span><span class="n">zmin</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#profiles.plot(zmax=12000, vmin=1e1, vmax=1e5, log=True, cmap=&#39;viridis&#39;)</span>

    <span class="n">profiles</span><span class="o">.</span><span class="n">foc</span><span class="p">(</span><span class="n">zmin</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="c1">#profiles.quickplot(zmax=12000, vmin=1e1, vmax=1e5, log=True, add_fog=True, cmap=&#39;viridis&#39;)</span>

    <span class="n">profiles</span><span class="o">.</span><span class="n">clouds</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">_main</span><span class="p">()</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Augustin Mortier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>