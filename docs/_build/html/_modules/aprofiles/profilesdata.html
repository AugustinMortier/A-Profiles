<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aprofiles.profilesdata &mdash; A-Profiles  documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> A-Profiles
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">For users</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">A-Profiles</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>aprofiles.profilesdata</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aprofiles.profilesdata</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1"># @author Augustin Mortier</span>
<span class="c1"># @email augustinm@met.no</span>
<span class="c1"># @desc A-Profiles - ProfilesData class</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span> <span class="nn">aprofiles</span> <span class="k">as</span> <span class="nn">apro</span>


<div class="viewcode-block" id="ProfilesData"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData">[docs]</a><span class="k">class</span> <span class="nc">ProfilesData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class representing profiles data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;Data attribute (instance of :class:`xarray.Dataset`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> 
    
    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span> 
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong data type: an xarray Dataset is expected.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>



<div class="viewcode-block" id="ProfilesData.gaussian_filter"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.gaussian_filter">[docs]</a>    <span class="k">def</span> <span class="nf">gaussian_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function that applies a 2D gaussian filter in order to reduce high frequency noise.</span>

<span class="sd">        Args:</span>
<span class="sd">            var (str, optional): variable of the Dataset to be processed. Defaults to &#39;attenuated_backscatter_0&#39;.</span>
<span class="sd">            sigma (scalar or sequence of scalars, optional): Standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes. Defaults to 0.</span>
<span class="sd">            inplace (bool, optional): if True, replace the variable, else use a copy. Defaults to False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            ProfilesData object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>

        <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>

        <span class="c1">#apply gaussian filter</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">filtered_data</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copied_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">copied_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">filtered_data</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copied_dataset</span>
        <span class="c1">#add attribute</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;gaussian filter&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">sigma</span>
        <span class="k">return</span> <span class="n">new_dataset</span></div>



<div class="viewcode-block" id="ProfilesData.extrapolation_lowest_layers"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.extrapolation_lowest_layers">[docs]</a>    <span class="k">def</span> <span class="nf">extrapolation_lowest_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cst&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for extrapolating lowest layers below a certain altitude. This is of particular intrest for instruments subject to After Pulse effect, with saturated signal in the lowest layers.</span>
<span class="sd">        We recommend to use a value of zmin=150m due to random values often found below that altitude which perturbs the clouds detection.</span>

<span class="sd">        Args:</span>
<span class="sd">            var (str, optional): variable of the Dataset to be processed. Defaults to &#39;attenuated_backscatter_0&#39;.</span>
<span class="sd">            zmin (float, optional): Altitude (in m, AGL) below which the signal is extrapolated. Defaults to 0.</span>
<span class="sd">            method (str, optional): &#39;cst&#39; or &#39;lin&#39; Method to be used for extrapolation of lowest layers. Defaults to &#39;cst&#39;.</span>
<span class="sd">            inplace (bool, optional): if True, replace the variable. Defaults to False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            ProfilesData object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#get index of zmin</span>
        <span class="n">zmin_asl</span> <span class="o">=</span> <span class="n">zmin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">station_altitude</span><span class="o">.</span><span class="n">data</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">zmin_asl</span><span class="p">))</span>
        
        <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cst&#39;</span><span class="p">:</span>
            <span class="c1">#get values at imin</span>
            <span class="n">data_zmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">imin</span><span class="p">]</span>
            <span class="c1">#generates ones matrice with time/altitude dimension to fill up bottom</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span><span class="n">imin</span><span class="p">))</span>
            <span class="c1">#replace values</span>
            <span class="n">filling_matrice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ones</span><span class="p">),</span><span class="n">data_zmin</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lin&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Linear extrapolation is not implemented yet&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected string: lin or cst&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">filling_matrice</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copied_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">copied_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">filling_matrice</span>
            <span class="n">new_dataset</span> <span class="o">=</span> <span class="n">copied_dataset</span>
        
        <span class="c1">#add attributes</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;extrapolation_low_layers_altitude_agl&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">zmin</span>
        <span class="n">new_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;extrapolation_low_layers_method&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">method</span>
        <span class="k">return</span> <span class="n">new_dataset</span></div>


    
<div class="viewcode-block" id="ProfilesData.range_correction"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.range_correction">[docs]</a>    <span class="k">def</span> <span class="nf">range_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method that corrects the solid angle effect (1/z2) which makes that the backscatter beam more unlikely to be detected with the square of the altitude.</span>

<span class="sd">        Args:</span>
<span class="sd">            var (str, optional): variable of the Dataset to be processed. Defaults to &#39;attenuated_backscatter_0&#39;.</span>
<span class="sd">            inplace (bool, optional): if True, replace the variable. Defaults to False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            ProfilesData object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#for the altitude correction, must one use the altitude above the ground level</span>
        <span class="n">z_agl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">station_altitude</span><span class="o">.</span><span class="n">data</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">range_corrected_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">z_agl</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">range_corrected_data</span>
            <span class="n">new_profiles_data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">copied_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">copied_dataset</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">range_corrected_data</span>
            <span class="n">new_profiles_data</span> <span class="o">=</span> <span class="n">copied_dataset</span>

        <span class="c1">#add attribute</span>
        <span class="n">new_profiles_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;range correction&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">return</span> <span class="n">new_profiles_data</span></div>



<div class="viewcode-block" id="ProfilesData.detect_fog_or_condensation"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.detect_fog_or_condensation">[docs]</a>    <span class="k">def</span> <span class="nf">detect_fog_or_condensation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zmin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detects fog or condensation relying on the cloud base height &#39;cloud_base_height&#39; given by the constructor.</span>
<span class="sd">        Adds DataArray to DataSet</span>

<span class="sd">        Args:</span>
<span class="sd">            zmin (float): Altitude AGL (in m) below which a cloud base height is considered a fog or condensation situation. Note: 200 m seems to give good results.</span>
<span class="sd">            add_dataarray (bool, optional): Add dataset to datarray if True. Defaults to True.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            :class: `ProfilesData object` with additional data array &#39;fog_or_condensation&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">first_cloud_base_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cloud_base_height</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fog_or_condensation</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">zmin</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">first_cloud_base_height</span><span class="p">]</span>

        <span class="c1">#creates dataarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;fog_or_condensation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">fog_or_condensation</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Fog or condensation mask.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>
    
    
<div class="viewcode-block" id="ProfilesData.detect_clouds"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.detect_clouds">[docs]</a>    <span class="k">def</span> <span class="nf">detect_clouds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_avg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thr_noise</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Module for clouds detection.</span>

<span class="sd">        Args:</span>
<span class="sd">            time_avg (int, optional): in minutes, the time during which we aggregates the profiles before detecting clouds. Defaults to 1.</span>
<span class="sd">            zmin (float, optional): altitude AGL, in m, above which we look for clouds. Defaults to 0. We recommend using the same value as used in the extrapolation_low_layers method.</span>
<span class="sd">            thr_noise (float, optional): threshold used in the test to determine if a couple (base,peak) is significant: data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z). Defaults to 5.</span>
<span class="sd">            thr_clouds (float, optional): threshold used to discriminate aerosol from clouds: data[peak(z)] / data[base(z)] &gt;= thr_clouds. Defaults to 4.</span>
<span class="sd">            verbose (bool, optional): verbose mode. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class: `ProfilesData object` with additional data arrays &#39;clouds_bases&#39;, &#39;clouds_peaks&#39;, and &#39;clouds_tops&#39;. &#39;clouds_bases&#39; correspond to the bases of the clouds. &#39;clouds_peaks&#39; correspond to the maximum of backscatter signal measured in the clouds. &#39;clouds_tops&#39; correspond to the top of the cloud if the beam crosses the cloud. If not, the top corresponds to the first value where the signal becomes lower than the one measured at the base of the cloud.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_detect_clouds_from_rcs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">thr_noise</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="p">):</span>
            <span class="c1">#data: 1D range corrected signal (rcs)</span>
            <span class="c1">#zmin: altitude AGL, in m, above which we detect clouds</span>
            <span class="c1">#thr_noise = 10 #threshold used in the test to determine if a couple (base,peak) is significant: data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z)</span>
            <span class="c1">#thr_clouds = 1.5 #threshold used to discriminate aerosol from clouds: data[peak(z)] / data[base(z)] &gt;= thr_clouds</span>
            
            <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
            <span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">uniform_filter1d</span>

            <span class="c1">#some useful functions:</span>
            <span class="k">def</span> <span class="nf">get_indexes</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="c1">#mask: list of Bool</span>
                <span class="c1">#returns a list indexes where the mask is True</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
            
            <span class="k">def</span> <span class="nf">make_mask</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">indexes_where_True</span><span class="p">):</span>
                <span class="c1">#length: int: length of the mask</span>
                <span class="c1">#indexes_where_true: list</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">length</span><span class="p">)])</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">indexes_where_True</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes_where_True</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">mask</span>

            <span class="c1">#0. rolling average</span>
            <span class="n">avg_data</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


            <span class="c1">#1. first derivative</span>
            <span class="n">ddata_dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


            <span class="c1">#2. identifies peaks and base by checking the sign changes of the derivative</span>
            <span class="n">sign_changes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">ddata_dz</span><span class="p">),</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">all_bases</span> <span class="o">=</span> <span class="n">sign_changes</span><span class="o">==</span><span class="mi">2</span>
            <span class="n">all_peaks</span> <span class="o">=</span> <span class="n">sign_changes</span><span class="o">==-</span><span class="mi">2</span>
            <span class="c1">#limit to bases above zmin</span>
            <span class="n">zmin_asl</span> <span class="o">=</span> <span class="n">zmin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">station_altitude</span><span class="o">.</span><span class="n">data</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">zmin_asl</span><span class="p">))</span>
            <span class="n">all_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]))]</span>
            <span class="n">all_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">imin</span><span class="p">]))]</span>
            
            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_peaks</span><span class="p">)</span>


            <span class="c1">#3. the signal should start with a base</span>
            <span class="k">if</span> <span class="n">i_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1">#set base as the minimum between peak and n gates under</span>
                <span class="n">gates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">i_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">gates</span><span class="p">[</span><span class="n">gates</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]]])</span>
                <span class="n">all_bases</span><span class="p">[</span><span class="n">i_base</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="c1">#update indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">all_bases</span><span class="p">)</span>

            
            <span class="c1">#4. keeps significant couples (base,peak)</span>
            <span class="c1"># a layer can be considered as a proper layer if the difference of signal between the peak and the base is significant (larger than the noise level)</span>
            <span class="c1"># noise evaluation (using a high passing frequency filter)</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="c1">#rolling average of the noise</span>
            <span class="n">avg_abs_noise</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">noise</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="c1">#make sure we have as many peaks as bases</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">):</span>
                <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)])</span>
                <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">i_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_len</span><span class="p">]</span>
                <span class="n">i_bases</span> <span class="o">=</span> <span class="n">i_bases</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">min_len</span><span class="p">]</span>
                

            <span class="c1"># data[peak(z)] - data[base(z)] &gt;= thr_noise * noise(z)</span>
            <span class="n">bases</span><span class="p">,</span> <span class="n">peaks</span> <span class="o">=</span> <span class="n">all_bases</span><span class="p">,</span> <span class="n">all_peaks</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_bases</span><span class="p">):</span>
                <span class="c1">#data_around_peak = np.mean(data[i_peaks[i]-1:i_peaks[i]+1])</span>
                <span class="c1">#data_around_base = np.mean(data[i_bases[i]-1:i_bases[i]+1])</span>
                <span class="n">data_around_peak</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">data_around_base</span> <span class="o">=</span> <span class="n">avg_data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">data_around_peak</span> <span class="o">-</span> <span class="n">data_around_base</span> <span class="o">&lt;=</span> <span class="n">thr_noise</span> <span class="o">*</span> <span class="n">avg_abs_noise</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>


            <span class="c1">#5. make sure we finish by a peak: remove last base </span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">i_peaks</span><span class="p">):</span>
                <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">i_bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1">#6. distinction between aerosol and clouds</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_bases</span><span class="p">):</span>
                <span class="n">data_around_peak</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">data_around_base</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">data_around_peak</span> <span class="o">-</span> <span class="n">data_around_base</span><span class="p">)</span> <span class="o">/</span> <span class="n">data_around_base</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thr_clouds</span><span class="p">:</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
            

            <span class="c1">#7. find tops of clouds layers</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
            <span class="c1"># conditions: look for bases above i_peaks[i], and data[top[i]] &lt;= data[base[i]]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_bases</span><span class="p">):</span>
                <span class="n">mask_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">&lt;</span><span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">mask_altitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))])</span>
                <span class="n">mask_altitude</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1">#the top is the first value that corresponds to the intersection of the two masks</span>
                <span class="n">cross_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">mask_value</span><span class="p">,</span> <span class="n">mask_altitude</span><span class="p">)</span>
                <span class="n">i_cross_mask</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">cross_mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_cross_mask</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                        <span class="c1">#print(&#39;top already found. remove current layer&#39;)</span>
                        <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#print(&#39;found top at &#39;,i_cross_mask[0], &#39;for base &#39;,i_bases[i])</span>
                        <span class="n">tops</span><span class="p">[</span><span class="n">i_cross_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print(&#39;no top found for base&#39;,i_bases[i])</span>
                    <span class="n">bases</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">peaks</span><span class="p">[</span><span class="n">i_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1">#get indexes</span>
            <span class="n">i_bases</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
            <span class="n">i_tops</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>

            
            <span class="c1">#8. merge layers: just focus on bases and tops</span>
            <span class="c1">#drop layer if base of next layer below top of current layer top of current layer</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">i_bases</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">i_tops</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            
            <span class="c1">#9. rebuild base and top masks</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_bases</span><span class="p">)</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="p">[])</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">i_tops</span><span class="p">)</span>
            <span class="c1">#find peaks between bases and tops</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_bases</span><span class="p">)):</span>
                <span class="n">peaks</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i_bases</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i_tops</span><span class="p">[</span><span class="n">i</span><span class="p">]])]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1">#get new indexes</span>
            <span class="n">i_peaks</span> <span class="o">=</span> <span class="n">get_indexes</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
            
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            #some plotting</span>
<span class="sd">            fig, axs = plt.subplots(1,2,figsize=(10,10))</span>
<span class="sd">            </span>
<span class="sd">            ymin, ymax = 000, 15000</span>
<span class="sd">            altitude_agl = profiles.data.altitude.data - profiles.data.station_altitude.data</span>
<span class="sd">            </span>
<span class="sd">            #signal on the left</span>
<span class="sd">            axs[0].plot(data, altitude_agl, &#39;b&#39;, label=&#39;rcs&#39;)</span>
<span class="sd">            axs[0].plot(avg_data, altitude_agl, &#39;c&#39;, label=&#39;rcs&#39;)</span>
<span class="sd">            axs[0].plot(avg_abs_noise,altitude_agl,&#39;:b&#39;, label=&#39;noise level&#39;)</span>
<span class="sd">            axs[0].plot(avg_abs_noise*thr_noise,altitude_agl,&#39;:b&#39;, label=&#39;noise level * {}&#39;.format(thr_noise))</span>
<span class="sd">            axs[0].plot(data[bases], altitude_agl[bases], &#39;&lt;g&#39;, label=&#39;bases&#39;)</span>
<span class="sd">            axs[0].plot(data[peaks], altitude_agl[peaks], &#39;&gt;r&#39;, label=&#39;peaks&#39;)</span>
<span class="sd">            axs[0].plot(data[tops], altitude_agl[tops], &#39;^k&#39;, label=&#39;tops&#39;)</span>
<span class="sd">            </span>
<span class="sd">            #set axis</span>
<span class="sd">            axs[0].set_ylim([ymin, ymax])</span>
<span class="sd">            #axs[0].set_xlim([-20000,20000])</span>
<span class="sd">            axs[0].legend()</span>

<span class="sd">            #derivative on the right</span>
<span class="sd">            axs[1].plot(ddata_dz, altitude_agl, &#39;b&#39;, label=&#39;first derivative&#39;)</span>
<span class="sd">            axs[1].plot(ddata_dz[bases], altitude_agl[bases], &#39;&lt;g&#39;, label=&#39;bases&#39;)</span>
<span class="sd">            axs[1].plot(ddata_dz[peaks], altitude_agl[peaks], &#39;&gt;r&#39;, label=&#39;peaks&#39;)</span>
<span class="sd">            </span>
<span class="sd">            axs[1].set_ylim([ymin, ymax])</span>
<span class="sd">            axs[1].legend()</span>
<span class="sd">            #set title</span>
<span class="sd">            fig.suptitle(t,weight=&#39;bold&#39;)</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;bases&#39;</span><span class="p">:</span> <span class="n">bases</span><span class="p">,</span>
                <span class="s1">&#39;peaks&#39;</span><span class="p">:</span> <span class="n">peaks</span><span class="p">,</span>
                <span class="s1">&#39;tops&#39;</span><span class="p">:</span> <span class="n">tops</span><span class="p">,</span>
            <span class="p">}</span>


        <span class="c1">#make sure some corrections have been done before</span>
        <span class="c1">#if &#39;range correction&#39; not in self.data.attenuated_backscatter_0.attrs or not self.data.attenuated_backscatter_0.attrs[&#39;range correction&#39;]:</span>
        <span class="c1">#    print(&#39;The range correction has not been applied to the backscatter profiles&#39;)</span>
        <span class="c1">#    pass</span>

        <span class="c1">#we work on profiles averaged in time to reduce the noise</span>
        <span class="n">rcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attenuated_backscatter_0</span>
        <span class="n">t_avg</span> <span class="o">=</span> <span class="n">time_avg</span> <span class="o">*</span> <span class="mi">60</span> <span class="c1">#s</span>
        <span class="c1">#time resolution in profiles data</span>
        <span class="n">dt_s</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[s]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">#number of timestamps to be to averaged</span>
        <span class="n">nt_avg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="nb">round</span><span class="p">(</span><span class="n">t_avg</span><span class="o">/</span><span class="n">dt_s</span><span class="p">)])</span>
        <span class="n">rcs</span> <span class="o">=</span> <span class="n">rcs</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">nt_avg</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>

        <span class="n">clouds_bases</span><span class="p">,</span> <span class="n">clouds_peaks</span><span class="p">,</span> <span class="n">clouds_tops</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">))):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">rcs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="n">clouds</span> <span class="o">=</span> <span class="n">_detect_clouds_from_rcs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">thr_noise</span><span class="p">,</span> <span class="n">thr_clouds</span><span class="p">)</span>
            
            <span class="c1">#store info in 2D array</span>
            <span class="n">clouds_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;bases&#39;</span><span class="p">])</span>
            <span class="n">clouds_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;peaks&#39;</span><span class="p">])</span>
            <span class="n">clouds_tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clouds</span><span class="p">[</span><span class="s1">&#39;tops&#39;</span><span class="p">])</span>
        
        <span class="c1">#creates dataarrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_bases&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">clouds_bases</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Mask - Base height of clouds&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
                <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">clouds_peaks</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Mask - Peak height of clouds&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
                <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;clouds_tops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">clouds_tops</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;altitude&quot;</span><span class="p">],</span>
            <span class="n">coords</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">altitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">altitude</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Mask - Top height of clouds&quot;</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                <span class="n">time_avg</span><span class="o">=</span><span class="n">time_avg</span><span class="p">,</span>
                <span class="n">thr_noise</span><span class="o">=</span><span class="n">thr_noise</span><span class="p">,</span>
                <span class="n">thr_clouds</span><span class="o">=</span><span class="n">thr_clouds</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="ProfilesData.plot"><a class="viewcode-back" href="../../api.html#aprofiles.profilesdata.ProfilesData.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s1">&#39;attenuated_backscatter_0&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_fog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_pbl</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_clouds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdYlBu_r&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot 2D Quicklook</span>

<span class="sd">        Args:</span>
<span class="sd">            var (str, optional): Variable of ProfilesData.data Dataset to be plotted. Defaults to &#39;attenuated_backscatter_0&#39;.</span>
<span class="sd">            time (np.datetime64, optional): if provided, plot the profile for closest time. If not, plot an image constructed on all profiles.Defaults to None</span>
<span class="sd">            zmin (float, optional): Minimum altitude AGL (m). Defaults to minimum available altitude.</span>
<span class="sd">            zmax (float, optional): Maximum altitude AGL (m). Defaults to maximum available altitude.</span>
<span class="sd">            vmin (float, optional): Minimum value. Defaults to 0.</span>
<span class="sd">            vmax (float, optional): Maximum value. If None, calculates max from data.</span>
<span class="sd">            log (bool, optional), Use logarithmic scale. Defaults to None.</span>
<span class="sd">            show_fog (bool, optional): Add fog detection. Defaults to False.</span>
<span class="sd">            show_pbl (bool, optional): Add PBL height. Defaults to False.</span>
<span class="sd">            show_clouds (bool, optional): Add clouds detection. Defaults to False.</span>
<span class="sd">            cmap (str, optional): Matplotlib colormap. Defaults to &#39;Spectral_r&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">apro</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">show_fog</span><span class="p">,</span> <span class="n">show_pbl</span><span class="p">,</span> <span class="n">show_clouds</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">apro</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">profile</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">show_fog</span><span class="p">,</span> <span class="n">show_pbl</span><span class="p">,</span> <span class="n">show_clouds</span><span class="p">)</span> </div></div>
    


<span class="k">def</span> <span class="nf">_main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">aprofiles</span> <span class="k">as</span> <span class="nn">apro</span>
    <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;data/e-profile/2021/09/08/L2_0-20000-006735_A20210908.nc&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;data/e-profile/2021/09/09/L2_0-20000-001492_A20210909.nc&quot;</span>
    <span class="n">profiles</span> <span class="o">=</span> <span class="n">apro</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">ReadProfiles</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="c1">#profiles.quickplot(&#39;attenuated_backscatter_0&#39;, vmin=0, vmax=1, cmap=&#39;viridis&#39;)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">range_correction</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">profiles</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">1e0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">1e5</span><span class="p">)</span>

    <span class="n">profiles</span><span class="o">.</span><span class="n">extrapolation_lowest_layers</span><span class="p">(</span><span class="n">zmin</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#profiles.plot(zmax=12000, vmin=1e1, vmax=1e5, log=True, cmap=&#39;viridis&#39;)</span>

    <span class="n">profiles</span><span class="o">.</span><span class="n">detect_fog_or_condensation</span><span class="p">(</span><span class="n">zmin</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="c1">#profiles.quickplot(zmax=12000, vmin=1e1, vmax=1e5, log=True, add_fog=True, cmap=&#39;viridis&#39;)</span>

    <span class="n">profiles</span><span class="o">.</span><span class="n">detect_clouds</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">_main</span><span class="p">()</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Augustin Mortier.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>